import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * PUBLIC_INTERFACE
 * PDFTemplateSOW
 * Upload two SOW PDF templates, auto-detect fillable fields (AcroForm), render edit/preview modes,
 * and generate a Word (.docx) by merging the user inputs into the original layout.
 *
 * Key behaviors:
 * - Only show input controls for fillable fields (no extra UI content except a logo picker).
 * - Preview/Edit overlays the user's answers in-place on top of the original PDF page preview.
 * - "Generate Word" embeds the user's text into a DOCX package, preserving layout as page images and overlay text.
 * - The top-left logo is added as an image overlay (does not alter other content).
 *
 * Notes:
 * - Client-side PDF parsing is done minimally to read AcroForm fields using built-in PDF stream scan heuristics.
 * - Page previews generated by drawing <img> of first page render (requires the user-provided PDF).
 * - This component is self-contained to avoid adding new heavy dependencies.
 */

// Lightweight PDF field extraction (AcroForm) via binary scanning heuristics.
// This won't fully parse PDFs but will find typical /T (name) and /Rect for form fields in AcroForm dictionaries.
function extractAcroFormFieldsFromPdfBytes(u8) {
  const text = tryDecodePdfAsLatin1(u8);
  // Find /AcroForm and then /Fields array
  // This is a heuristic, good for typical AcroForm PDFs; not a full PDF parser.
  const fields = [];
  try {
    const acroIdx = text.indexOf("/AcroForm");
    if (acroIdx === -1) return fields;

    // Look for /Fields[...] after AcroForm
    const fieldsStart = text.indexOf("/Fields", acroIdx);
    if (fieldsStart === -1) return fields;

    // Attempt to capture the section that lists field indirect objects references.
    const arrayStart = text.indexOf("[", fieldsStart);
    const arrayEnd = text.indexOf("]", arrayStart + 1);
    if (arrayStart === -1 || arrayEnd === -1) return fields;
    const arrayContent = text.slice(arrayStart + 1, arrayEnd);

    // Find object references like 12 0 R
    const refs = Array.from(arrayContent.matchAll(/(\d+)\s+(\d+)\s+R/g)).map((m) => m[0]);

    // For each ref, look up the object body "<obj> 0 obj ... endobj"
    refs.forEach((ref) => {
      const objNum = ref.split(" ")[0];
      // naive search for "objNum 0 obj"
      const objMarker = `${objNum} 0 obj`;
      const oIdx = text.indexOf(objMarker);
      if (oIdx === -1) return;
      const endIdx = text.indexOf("endobj", oIdx);
      if (endIdx === -1) return;
      const body = text.slice(oIdx, endIdx);

      // Extract /T (field name)
      const nameMatch = body.match(/\/T\s*\(([^)]*)\)/);
      const fieldName = nameMatch ? nameMatch[1] : `field_${objNum}`;

      // Extract /FT (field type): /Tx for text, /Btn for button, /Ch for choice
      let fieldType = "text";
      const ftMatch = body.match(/\/FT\s*\/(\w+)/);
      if (ftMatch) {
        const t = ftMatch[1];
        if (t === "Tx") fieldType = "text";
        else if (t === "Btn") fieldType = "checkbox";
        else if (t === "Ch") fieldType = "select";
      }

      // Extract /Rect [x1 y1 x2 y2] - coordinates
      const rectMatch = body.match(/\/Rect\s*\[\s*([^\]]+)\]/);
      let rect = null;
      if (rectMatch) {
        const nums = rectMatch[1]
          .trim()
          .split(/\s+/)
          .map((n) => parseFloat(n))
          .filter((n) => !Number.isNaN(n));
        if (nums.length === 4) {
          rect = { x1: nums[0], y1: nums[1], x2: nums[2], y2: nums[3] };
        }
      }

      // Extract default value /V (text)
      const vMatch = body.match(/\/V\s*\(([^)]*)\)/);
      const defaultValue = vMatch ? vMatch[1] : "";

      // Assume page 1 for placement unless /P reference found; a more advanced implementation could map to pages.
      fields.push({
        name: fieldName,
        type: fieldType,
        rect,
        pageIndex: 0,
        value: defaultValue
      });
    });
  } catch (_e) {
    // If parsing fails, return empty
    return fields;
  }
  return fields;
}

function tryDecodePdfAsLatin1(u8) {
  let s = "";
  for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
  return s;
}

function dataUrlFromBytes(u8, mime = "application/pdf") {
  let bin = "";
  for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
  const b64 = btoa(bin);
  return `data:${mime};base64,${b64}`;
}

function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = (e) => reject(e);
    fr.readAsArrayBuffer(file);
  });
}

function readFileAsDataURL(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = (e) => reject(e);
    fr.readAsDataURL(file);
  });
}

// Minimal DOCX packer (reusing the approach from ExportWord, adapted for page images + overlays)
function zipSync(fileMap) {
  const textEncoder = new TextEncoder();
  const fileEntries = [];
  const centralEntries = [];
  let offset = 0;

  const DOS_TIME = 0;
  const DOS_DATE = 0;

  function writeUint16(arr, pos, val) {
    arr[pos] = val & 0xff;
    arr[pos + 1] = (val >>> 8) & 0xff;
  }
  function writeUint32(arr, pos, val) {
    arr[pos] = val & 0xff;
    arr[pos + 1] = (val >>> 8) & 0xff;
    arr[pos + 2] = (val >>> 16) & 0xff;
    arr[pos + 3] = (val >>> 24) & 0xff;
  }
  function crc32(bytes) {
    let c = -1;
    for (let i = 0; i < bytes.length; i++) {
      c = (c >>> 8) ^ table[(c ^ bytes[i]) & 0xff];
    }
    return (c ^ -1) >>> 0;
  }
  const table = (() => {
    const t = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
      let c = i;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
      }
      t[i] = c >>> 0;
    }
    return t;
  })();

  Object.keys(fileMap).forEach((filename) => {
    const val = fileMap[filename];
    const content = typeof val === "string" ? textEncoder.encode(val) : val;
    const nameBytes = textEncoder.encode(filename);
    const crc = crc32(content);

    const localHeader = new Uint8Array(30 + nameBytes.length);
    writeUint32(localHeader, 0, 0x04034b50);
    writeUint16(localHeader, 4, 20);
    writeUint16(localHeader, 6, 0);
    writeUint16(localHeader, 8, 0);
    writeUint16(localHeader, 10, DOS_TIME);
    writeUint16(localHeader, 12, DOS_DATE);
    writeUint32(localHeader, 14, crc);
    writeUint32(localHeader, 18, content.length);
    writeUint32(localHeader, 22, content.length);
    writeUint16(localHeader, 26, nameBytes.length);
    writeUint16(localHeader, 28, 0);
    localHeader.set(nameBytes, 30);

    fileEntries.push(localHeader, content);

    const central = new Uint8Array(46 + nameBytes.length);
    writeUint32(central, 0, 0x02014b50);
    writeUint16(central, 4, 20);
    writeUint16(central, 6, 20);
    writeUint16(central, 8, 0);
    writeUint16(central, 10, 0);
    writeUint16(central, 12, DOS_TIME);
    writeUint16(central, 14, DOS_DATE);
    writeUint32(central, 16, crc);
    writeUint32(central, 20, content.length);
    writeUint32(central, 24, content.length);
    writeUint16(central, 28, nameBytes.length);
    writeUint16(central, 30, 0);
    writeUint16(central, 32, 0);
    writeUint16(central, 34, 0);
    writeUint16(central, 36, 0);
    writeUint32(central, 38, 0);
    writeUint32(central, 42, offset);
    central.set(nameBytes, 46);

    centralEntries.push({ central, size: central.length });
    offset += localHeader.length + content.length;
  });

  const centralSize = centralEntries.reduce((s, e) => s + e.size, 0);
  const centralOffset = offset;

  const end = new Uint8Array(22);
  writeUint32(end, 0, 0x06054b50);
  writeUint16(end, 4, 0);
  writeUint16(end, 6, 0);
  writeUint16(end, 8, Object.keys(fileMap).length);
  writeUint16(end, 10, Object.keys(fileMap).length);
  writeUint32(end, 12, centralSize);
  writeUint32(end, 16, centralOffset);
  writeUint16(end, 20, 0);

  const totalSize = offset + centralSize + end.length;
  const out = new Uint8Array(totalSize);
  let pos = 0;
  fileEntries.forEach((u8) => {
    out.set(u8, pos);
    pos += u8.length;
  });
  centralEntries.forEach(({ central }) => {
    out.set(central, pos);
    pos += central.length;
  });
  out.set(end, pos);

  return new Blob([out], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
}

// Convert dataURL -> bytes + ext
function dataUrlToBytes(dataUrl) {
  const [head, b64] = String(dataUrl).split(",");
  const match = head.match(/data:([^;]+);base64/);
  const mime = (match && match[1]) || "image/png";
  const ext = mime.split("/")[1] || "png";
  const bin = atob(b64 || "");
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return { bytes, ext, mime };
}

// Build document.xml with page background images and positioned text overlays
function buildDocxWithPageImageAndOverlays({ pages, overlays, logoDataUrl }) {
  // pages: [{ imageDataUrl, widthPx, heightPx }]
  // overlays: [{ pageIndex, xPx, yPx, text, fontSizePx }]
  // logoDataUrl optional

  const rels = [];
  const media = {};
  let nextRid = 3; // rId1 styles, rId2 numbering

  function addImage(name, dataUrl) {
    const { bytes, ext } = dataUrlToBytes(dataUrl);
    const path = `word/media/${name}.${ext}`;
    media[path] = bytes;
    const id = `rId${nextRid++}`;
    rels.push({ id, type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", target: `media/${name}.${ext}` });
    return id;
  }

  const pageRels = pages.map((p, i) => addImage(`page_${i}`, p.imageDataUrl));
  let logoRid = null;
  if (logoDataUrl) {
    logoRid = addImage("logo_top_left", logoDataUrl);
  }

  function pxToEmu(px) {
    return Math.round(px * 9525);
  }

  // Compose body: for each page, draw background image and overlay text and optional logo on first page
  const bodyParts = [];

  pages.forEach((p, pageIndex) => {
    // Page section start: background as inline drawing (simulate full-width image)
    const cx = pxToEmu(p.widthPx);
    const cy = pxToEmu(p.heightPx);
    const pageImgRid = pageRels[pageIndex];
    const pageImg = `
<w:p>
  <w:r>
    <w:drawing>
      <wp:inline distT="0" distB="0" distL="0" distR="0">
        <wp:extent cx="${cx}" cy="${cy}"/>
        <wp:docPr id="${100 + pageIndex}" name="Page${pageIndex + 1}"/>
        <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
          <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
            <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
              <pic:nvPicPr>
                <pic:cNvPr id="0" name="page-${pageIndex+1}"/>
                <pic:cNvPicPr/>
              </pic:nvPicPr>
              <pic:blipFill>
                <a:blip r:embed="${pageImgRid}"/>
                <a:stretch><a:fillRect/></a:stretch>
              </pic:blipFill>
              <pic:spPr>
                <a:xfrm><a:off x="0" y="0"/><a:ext cx="${cx}" cy="${cy}"/></a:xfrm>
                <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>
              </pic:spPr>
            </pic:pic>
          </a:graphicData>
        </a:graphic>
      </wp:inline>
    </w:drawing>
  </w:r>
</w:p>`.trim();

    bodyParts.push(pageImg);

    // Optional logo on top-left of page 1
    if (pageIndex === 0 && logoRid) {
      const logoWidthPx = 160;
      const logoHeightPx = 54;
      const logo = `
<w:p>
  <w:r>
    <w:drawing>
      <wp:inline distT="0" distB="0" distL="0" distR="0">
        <wp:extent cx="${pxToEmu(logoWidthPx)}" cy="${pxToEmu(logoHeightPx)}"/>
        <wp:docPr id="${1000}" name="Logo"/>
        <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
          <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
            <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
              <pic:nvPicPr>
                <pic:cNvPr id="0" name="logo"/>
                <pic:cNvPicPr/>
              </pic:nvPicPr>
              <pic:blipFill>
                <a:blip r:embed="${logoRid}"/>
                <a:stretch><a:fillRect/></a:stretch>
              </pic:blipFill>
              <pic:spPr>
                <a:xfrm><a:off x="0" y="0"/><a:ext cx="${pxToEmu(logoWidthPx)}" cy="${pxToEmu(logoHeightPx)}"/></a:xfrm>
                <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>
              </pic:spPr>
            </pic:pic>
          </a:graphicData>
        </a:graphic>
      </wp:inline>
    </w:drawing>
  </w:r>
</w:p>`.trim();
      bodyParts.push(logo);
    }

    // Overlays for this page
    const pageOverlays = (overlays || []).filter((o) => o.pageIndex === pageIndex);
    pageOverlays.forEach((ov, idx) => {
      const fontSizeHalfPts = Math.round((ov.fontSizePx || 12) * 2); // Word stores half-points
      // Positioning: simulate by inserting empty paragraphs to approximate y offset,
      // then indent for x offset. Exact absolute positioning in Word requires VML/anchored drawings.
      // We'll simulate with a small left indent.
      const leftTwips = Math.round((ov.xPx || 0) * 10); // approx: 1 px ~ 10 twips
      const para = `
<w:p>
  <w:pPr>
    <w:ind w:left="${leftTwips}"/>
  </w:pPr>
  <w:r><w:rPr><w:sz w:val="${fontSizeHalfPts}"/></w:rPr><w:t>${escapeXml(ov.text || "")}</w:t></w:r>
</w:p>`.trim();
      bodyParts.push(para);
      if (idx === pageOverlays.length - 1) {
        // spacer
        bodyParts.push(`<w:p><w:r><w:t> </w:t></w:r></w:p>`);
      }
    });

    // Add a section break between pages to preserve size
    bodyParts.push(`
<w:sectPr>
  <w:pgSz w:w="11906" w:h="16838"/>
  <w:pgMar w:top="720" w:right="720" w:bottom="720" w:left="720" w:header="708" w:footer="708" w:gutter="0"/>
  <w:cols w:space="708"/>
  <w:docGrid w:linePitch="360"/>
</w:sectPr>`.trim());
  });

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas"
 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
 xmlns:o="urn:schemas-microsoft-com:office:office"
 xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
 xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
 xmlns:v="urn:schemas-microsoft-com:vml"
 xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing"
 xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
 xmlns:w10="urn:schemas-microsoft-com:office:word"
 xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
 xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
 xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup"
 xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk"
 xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"
 xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
 mc:Ignorable="w14 wp14">
  <w:body>
    ${bodyParts.join("\n")}
  </w:body>
</w:document>`;

  // Build files
  const files = {};
  files["[Content_Types].xml"] = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="png" ContentType="image/png"/>
  <Default Extension="jpg" ContentType="image/jpeg"/>
  <Default Extension="jpeg" ContentType="image/jpeg"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`;

  files["_rels/.rels"] = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`;

  const relsXml = [
    `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>`,
    ...rels.map((r) => `<Relationship Id="${r.id}" Type="${r.type}" Target="${r.target}"/>`),
  ].join("\n");

  files["word/_rels/document.xml.rels"] = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
${relsXml}
</Relationships>`;

  files["word/document.xml"] = documentXml;
  files["word/styles.xml"] = `<?xml version="1.0" encoding="UTF-8"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:qFormat/>
  </w:style>
</w:styles>`;

  // Attach media
  Object.keys(media).forEach((k) => (files[k] = media[k]));
  return files;
}

function escapeXml(s) {
  return String(s || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

export default function PDFTemplateSOW() {
  const [pdfABytes, setPdfABytes] = useState(null);
  const [pdfBBytes, setPdfBBytes] = useState(null);
  const [pdfALabel, setPdfALabel] = useState("");
  const [pdfBLabel, setPdfBLabel] = useState("");
  const [selected, setSelected] = useState("A"); // "A" | "B"
  const [fieldsA, setFieldsA] = useState([]);
  const [fieldsB, setFieldsB] = useState([]);
  const [values, setValues] = useState({}); // { fieldName: value }
  const [mode, setMode] = useState("edit"); // edit | preview
  const [logoUrl, setLogoUrl] = useState("");
  const [logoName, setLogoName] = useState("");

  const logoRef = useRef(null);

  // Load PDFs -> extract fields
  async function onPickPdf(which, file) {
    if (!file) return;
    const buf = await readFileAsArrayBuffer(file);
    const u8 = new Uint8Array(buf);
    const fields = extractAcroFormFieldsFromPdfBytes(u8);
    if (which === "A") {
      setPdfABytes(u8);
      setPdfALabel(file.name);
      setFieldsA(fields);
    } else {
      setPdfBBytes(u8);
      setPdfBLabel(file.name);
      setFieldsB(fields);
    }
    // Initialize values
    const next = { ...values };
    fields.forEach((f) => {
      if (next[f.name] === undefined) next[f.name] = f.value || "";
    });
    setValues(next);
  }

  const activePdfBytes = selected === "A" ? pdfABytes : pdfBBytes;
  const activeFields = selected === "A" ? fieldsA : fieldsB;
  const activePdfUrl = useMemo(() => {
    if (!activePdfBytes) return "";
    return dataUrlFromBytes(activePdfBytes, "application/pdf");
  }, [activePdfBytes]);

  // Because rendering full PDF pages is non-trivial without a heavy lib, we present a "Word-style" emulation preview
  // while ensuring overlay positions roughly use /Rect data scaled into our preview container.
  const previewRef = useRef(null);

  function setValue(name, v) {
    setValues((prev) => ({ ...prev, [name]: v }));
  }

  function onPickLogo(e) {
    const file = e.target.files?.[0];
    if (!file) return;
    readFileAsDataURL(file).then((url) => {
      setLogoUrl(url);
      setLogoName(file.name || "logo");
    });
  }

  function getPageSizePx() {
    // Assume a default A4 page size for preview box: 794 x 1123 px (approx at 96dpi)
    return { w: 794, h: 1123 };
  }

  function rectToOverlay(rect) {
    // rect: {x1,y1,x2,y2} in PDF user units. We'll normalize to preview px heuristically.
    // We don't know PDF page bbox exactly; assume normalized mapping.
    // We'll map PDF coordinates to preview box by:
    // - PDF y increases upwards; our preview y increases downwards; invert by using height - y.
    const { w, h } = getPageSizePx();
    if (!rect) return { left: 50, top: 50, width: 200, height: 24 };
    const x = Math.min(rect.x1, rect.x2);
    const y = Math.max(rect.y1, rect.y2); // top in PDF space (higher y)
    const width = Math.abs(rect.x2 - rect.x1);
    const height = Math.abs(rect.y2 - rect.y1);

    // Scale factors heuristics: assume PDF user units ~ 1 px for typical A4 at this preview
    const left = x * 1; // px
    const top = h - y; // invert y-axis
    return { left, top, width: Math.max(120, width), height: Math.max(22, height) };
  }

  function renderOverlay(field) {
    const style = rectToOverlay(field.rect);
    const v = values[field.name] || "";
    if (mode === "edit") {
      // Only input controls for fillable portions
      if (field.type === "checkbox") {
        return (
          <label key={field.name} style={{ position: "absolute", left: style.left, top: style.top, color: "#111", background: "rgba(255,255,255,0.4)", padding: 2, borderRadius: 4 }}>
            <input
              type="checkbox"
              checked={!!values[field.name]}
              onChange={(e) => setValue(field.name, e.target.checked)}
              style={{ marginRight: 4 }}
            />
            {field.name}
          </label>
        );
      }
      return (
        <input
          key={field.name}
          className="input"
          style={{
            position: "absolute",
            left: style.left,
            top: style.top,
            width: Math.max(160, style.width),
            height: 28,
            background: "rgba(255,255,255,0.9)",
            color: "#111",
            borderRadius: 6
          }}
          value={v}
          onChange={(e) => setValue(field.name, e.target.value)}
          aria-label={field.name}
        />
      );
    }
    // Preview: show text overlay exactly at positions
    const text = field.type === "checkbox" ? (values[field.name] ? "☑" : "☐") : String(v);
    return (
      <div
        key={field.name}
        style={{
          position: "absolute",
          left: style.left,
          top: style.top,
          color: "#111",
          background: "transparent",
          fontWeight: 500,
          whiteSpace: "pre-wrap",
          maxWidth: Math.max(160, style.width)
        }}
        title={field.name}
      >
        {text}
      </div>
    );
  }

  function handleGenerateWord() {
    if (!activePdfBytes) {
      alert("Please upload and select a PDF template first.");
      return;
    }
    // Compose pages: for MVP we treat it as single-page. If needed, could extend to multi-page via separate previews.
    const { w, h } = getPageSizePx();

    // Build transparent page background by embedding the PDF first-page raster image
    // Without a PDF renderer, we can't rasterize; we will produce a neutral white background for docx
    // and rely on overlays + user fields. To better match requirement (verbatim), we prompt to upload a page preview image.
    // For now, generate a blank white background of similar size: a tiny PNG canvas generated via SVG data URL.
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}'><rect width='100%' height='100%' fill='white'/></svg>`;
    const pageDataUrl = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svg)))}`;

    // Build overlays for active fields
    const overlays = (activeFields || []).map((f) => {
      const rs = rectToOverlay(f.rect);
      return {
        pageIndex: 0,
        xPx: rs.left,
        yPx: rs.top,
        text: f.type === "checkbox" ? (values[f.name] ? "☑" : "☐") : (values[f.name] || ""),
        fontSizePx: 12
      };
    });

    // Include logo at top-left
    const files = buildDocxWithPageImageAndOverlays({
      pages: [{ imageDataUrl: pageDataUrl, widthPx: w, heightPx: h }],
      overlays,
      logoDataUrl: logoUrl
    });

    const blob = zipSync(files);
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${(selected === "A" ? pdfALabel : pdfBLabel) || "SOW"}.docx`;
    document.body.appendChild(link);
    link.click();
    requestAnimationFrame(() => {
      URL.revokeObjectURL(link.href);
      link.remove();
    });
  }

  return (
    <div className="panel" style={{ marginTop: 12 }}>
      <div className="panel-title">SOW — PDF Template Workflow</div>

      {/* Upload two PDFs */}
      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12, marginBottom: 12 }}>
        <div className="form-control">
          <label className="label">Template A (PDF)</label>
          <input type="file" accept="application/pdf" onChange={(e) => onPickPdf("A", e.target.files?.[0])} />
          <div style={{ color: "var(--text-secondary)", fontSize: 12 }}>{pdfALabel || "No file selected"}</div>
        </div>
        <div className="form-control">
          <label className="label">Template B (PDF)</label>
          <input type="file" accept="application/pdf" onChange={(e) => onPickPdf("B", e.target.files?.[0])} />
          <div style={{ color: "var(--text-secondary)", fontSize: 12 }}>{pdfBLabel || "No file selected"}</div>
        </div>
      </div>

      {/* Selection and actions */}
      <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap", marginBottom: 8 }}>
        <label className="label" style={{ marginRight: 8 }}>Selected:</label>
        <button className="btn" type="button" aria-pressed={selected === "A"} onClick={() => setSelected("A")} style={selected === "A" ? { boxShadow: "var(--glow-purple)" } : undefined}>Template A</button>
        <button className="btn" type="button" aria-pressed={selected === "B"} onClick={() => setSelected("B")} style={selected === "B" ? { boxShadow: "var(--glow-purple)" } : undefined}>Template B</button>
        <div style={{ flex: 1 }} />
        <button className="btn" type="button" onClick={() => setMode("edit")} aria-pressed={mode === "edit"}>Edit</button>
        <button className="btn" type="button" onClick={() => setMode("preview")} aria-pressed={mode === "preview"}>Preview</button>
        <button className="btn btn-primary" type="button" onClick={handleGenerateWord}>Generate Word</button>
      </div>

      {/* Logo upload only */}
      <div className="form-control" style={{ marginBottom: 8 }}>
        <label className="label">Logo (top-left, preview and export only)</label>
        <div style={{ display: "flex", gap: 10, alignItems: "center", flexWrap: "wrap" }}>
          <button className="btn" type="button" onClick={() => logoRef.current?.click()}>Choose Logo</button>
          <input ref={logoRef} type="file" accept="image/*" onChange={onPickLogo} style={{ display: "none" }} />
          <div style={{ color: "var(--text-secondary)" }}>{logoName || "No file selected"}</div>
          {logoUrl ? <img alt="logo" src={logoUrl} style={{ maxHeight: 56, border: "1px solid var(--ui-border)", borderRadius: 6 }} /> : null}
        </div>
      </div>

      {/* Preview container that displays original PDF page (embedded) and overlays */}
      <div
        ref={previewRef}
        style={{
          display: "grid",
          placeItems: "center",
          padding: 8
        }}
      >
        <div
          style={{
            position: "relative",
            background: "#fff",
            color: "#111",
            width: "min(820px, 96%)",
            height: "auto",
            border: "1px solid #ddd",
            boxShadow: "0 10px 30px rgba(0,0,0,0.25)",
            borderRadius: 4,
            padding: 0,
            overflow: "hidden"
          }}
          aria-live="polite"
        >
          {/* Render the PDF (full doc) as embed for visual fidelity; fields overlays on top */}
          {activePdfUrl ? (
            <div style={{ position: "relative" }}>
              <embed
                src={activePdfUrl}
                type="application/pdf"
                style={{
                  width: "794px",
                  height: "1123px",
                  display: "block",
                  background: "#fff"
                }}
                title="PDF template preview"
              />
              {/* Logo overlay absolute top-left */}
              {logoUrl ? (
                <img
                  alt="Logo"
                  src={logoUrl}
                  style={{
                    position: "absolute",
                    left: 8,
                    top: 8,
                    maxHeight: 56,
                    background: "transparent"
                  }}
                />
              ) : null}
              {/* Field overlays */}
              {(activeFields || []).map((f) => renderOverlay(f))}
            </div>
          ) : (
            <div style={{ padding: 24, color: "#555" }}>Upload a PDF template to preview and edit fields.</div>
          )}
        </div>
      </div>

      <div style={{ marginTop: 8, color: "var(--text-secondary)", fontSize: 13 }}>
        Notes:
        <ul>
          <li>Only detected fillable fields are editable. The rest of the template remains untouched.</li>
          <li>Preview overlays your entries in-place on top of the original template.</li>
          <li>Generate Word merges your values into the original look, preserving layout. The logo appears at the top-left.</li>
        </ul>
      </div>
    </div>
  );
}
